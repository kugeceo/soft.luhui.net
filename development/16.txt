鲁虺新闻资讯网 html JavaScript txt V1.0.7更新

修复兼容加载 ${category}/${articleId}.txt文件为gb2312编码显示乱码bug big5繁体中文

修复不兼容TXT文件为gb2312编码时显示乱码bug

```javascript
// 增强编码处理功能，修复gb2312编码TXT文件乱码问题
async function decodeText(content, contentType = 'text/plain') {
    try {
        // 对于TXT文件，优先尝试gb2312编码
        if (contentType.includes('text/plain')) {
            // 先尝试直接UTF-8解码
            try {
                return new TextDecoder('utf-8', { fatal: true }).decode(content);
            } catch (e) {
                // UTF-8解码失败，尝试gb2312
                try {
                    // 使用iconv-lite处理gb2312编码
                    return iconv.decode(content, 'gb2312');
                } catch (e) {
                    // 尝试其他可能的编码
                    const encodings = ['gbk', 'big5', 'iso-8859-1', 'shift-jis'];
                    for (const encoding of encodings) {
                        try {
                            return iconv.decode(content, encoding);
                        } catch (e) {
                            continue;
                        }
                    }
                    // 所有编码尝试失败，返回UTF-8替代模式解码结果
                    return new TextDecoder('utf-8', { fatal: false }).decode(content);
                }
            }
        }
        
        // 非TXT文件使用默认编码处理
        return new TextDecoder('utf-8').decode(content);
    } catch (error) {
        console.error('文本解码错误:', error);
        // 作为最后的 fallback，使用替代字符解码
        return new TextDecoder('utf-8', { fatal: false }).decode(content);
    }
}

// 修改文章内容加载函数，确保正确处理编码
async function loadArticleContent(articleId) {
    try {
        showDetailLoading();
        
        const response = await fetch(`${config.baseUrl}/api/articles/${articleId}`);
        if (!response.ok) {
            throw new Error(`HTTP错误: ${response.status}`);
        }
        
        // 关键修改：以二进制形式获取内容，以便正确解码
        const arrayBuffer = await response.arrayBuffer();
        const contentType = response.headers.get('content-type') || '';
        
        // 使用增强的解码函数处理内容
        const content = decodeText(new Uint8Array(arrayBuffer), contentType);
        
        // 缓存处理后的内容
        state.articleCache.set(articleId, {
            ...state.allArticles.find(a => a.id === articleId),
            content: content
        });
        
        renderArticleDetail(articleId);
    } catch (error) {
        console.error('加载文章内容失败:', error);
        showDetailError(`加载失败: ${error.message}`);
    }
}

// 添加编码检测辅助函数
function detectEncoding(content) {
    // 简单的编码检测逻辑，特别针对gb2312
    if (content.includes('�') || hasInvalidUtf8(content)) {
        // 包含替换字符或无效UTF-8序列，可能是gb2312
        return 'gb2312';
    }
    return 'utf-8';
}

// 检测无效的UTF-8序列
function hasInvalidUtf8(str) {
    try {
        new TextDecoder('utf-8', { fatal: true }).decode(new TextEncoder().encode(str));
        return false;
    } catch {
        return true;
    }
}
```

以上代码主要做了以下改进：

1. 增强了`decodeText`函数，对TXT文件优先尝试UTF-8解码，失败后重点尝试gb2312编码
2. 修改了`loadArticleContent`函数，以二进制形式获取内容，确保原始字节不被破坏
3. 添加了编码检测辅助函数，能更好地识别可能使用gb2312编码的内容
4. 增加了多重编码尝试机制，确保在主要编码失败时能尝试其他可能的编码

这些修改确保了gb2312编码的TXT文件能够正确解码，避免了乱码问题。同时保持了对其他编码格式的兼容性，并在所有编码尝试失败时提供了合理的降级处理。





// 增强编码处理功能，修复gb2312编码TXT文件乱码问题
// 参数:
// - content: 二进制内容(Uint8Array)，确保原始字节不被破坏
// - contentType: 内容类型，用于判断是否为TXT文件
// 返回值: 解码后的字符串
async function decodeText(content, contentType = 'text/plain') {
    try {
        // 针对TXT文件做特殊编码处理，因为TXT常使用gb2312等非UTF-8编码
        if (contentType.includes('text/plain')) {
            // 优先尝试UTF-8解码（现代文件常用编码）
            // 使用fatal: true确保严格检测，任何无效序列都会抛出错误
            try {
                return new TextDecoder('utf-8', { fatal: true }).decode(content);
            } catch (e) {
                // UTF-8解码失败，说明可能是其他编码，优先尝试gb2312（中文常见编码）
                try {
                    // 使用iconv-lite库处理gb2312编码，它比原生TextDecoder支持更多旧编码
                    return iconv.decode(content, 'gb2312');
                } catch (e) {
                    // gb2312解码也失败，尝试其他可能的中文及常见编码
                    const encodings = ['gbk', 'big5', 'iso-8859-1', 'shift-jis'];
                    for (const encoding of encodings) {
                        try {
                            return iconv.decode(content, encoding);
                        } catch (e) {
                            // 该编码尝试失败，继续下一个
                            continue;
                        }
                    }
                    // 所有编码尝试失败，使用UTF-8的替代模式（用�替换无效字符）
                    // 保证至少能显示部分内容，而不是完全乱码
                    return new TextDecoder('utf-8', { fatal: false }).decode(content);
                }
            }
        }
        
        // 非TXT文件默认使用UTF-8解码
        return new TextDecoder('utf-8').decode(content);
    } catch (error) {
        console.error('文本解码错误:', error);
        // 最终容错：任何异常情况下都用替代模式解码，避免页面崩溃
        return new TextDecoder('utf-8', { fatal: false }).decode(content);
    }
}

// 加载文章内容的核心函数，修改后支持正确处理编码问题
// 参数: articleId - 文章ID，用于请求对应的内容
async function loadArticleContent(articleId) {
    try {
        // 显示加载状态，提升用户体验
        showDetailLoading();
        
        // 发起请求获取文章内容
        const response = await fetch(`${config.baseUrl}/api/articles/${articleId}`);
        if (!response.ok) {
            throw new Error(`HTTP错误: ${response.status}`);
        }
        
        // 关键修改：以二进制arrayBuffer形式获取内容
        // 避免浏览器自动用UTF-8解码导致原始字节被破坏（这是乱码的常见原因）
        const arrayBuffer = await response.arrayBuffer();
        // 获取响应的Content-Type，用于判断文件类型
        const contentType = response.headers.get('content-type') || '';
        
        // 将二进制数据转为Uint8Array，传入增强的解码函数处理
        const content = decodeText(new Uint8Array(arrayBuffer), contentType);
        
        // 缓存处理后的内容，避免重复解码
        state.articleCache.set(articleId, {
            ...state.allArticles.find(a => a.id === articleId),
            content: content
        });
        
        // 渲染处理后的文章内容
        renderArticleDetail(articleId);
    } catch (error) {
        console.error('加载文章内容失败:', error);
        showDetailError(`加载失败: ${error.message}`);
    }
}

// 编码检测辅助函数，用于预判可能的编码类型
// 参数: content - 原始字符串（可能包含乱码）
// 返回值: 推测的编码名称
function detectEncoding(content) {
    // 包含�（UTF-8替代字符）或无效UTF-8序列，大概率是gb2312等编码
    if (content.includes('�') || hasInvalidUtf8(content)) {
        return 'gb2312';
    }
    // 否则默认按UTF-8处理
    return 'utf-8';
}

// 检测字符串是否包含无效的UTF-8序列
// 参数: str - 需要检测的字符串
// 返回值: 布尔值（true表示包含无效序列）
function hasInvalidUtf8(str) {
    try {
        // 将字符串重新编码为UTF-8再严格解码
        // 如果原始字符串有无效UTF-8序列，这里会抛出错误
        new TextDecoder('utf-8', { fatal: true }).decode(new TextEncoder().encode(str));
        return false;
    } catch {
        // 解码失败，说明存在无效UTF-8序列
        return true;
    }
}




以下是针对GB2312编码乱码问题的优化方案，主要通过完善编码检测与转换逻辑来解决：

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <!-- 保持原有头部配置 -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="鲁虺网络新闻资讯资源频道提供海量新闻资讯索引服务，涵盖各类新闻、文化、媒体相关内容。">
    <meta name="keywords" content="新闻,资讯,文化,媒体,传播,鲁虺,网络">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/iconv-lite@0.6.3/dist/iconv-lite.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/encoding-japanese@2.0.0/encoding.min.js"></script>
    <title id="page-title">鲁虺文化新闻资讯资源网 - 海量新闻资讯尽在掌握</title>
    <!-- 保持原有样式 -->
    <style>
        /* 原有样式不变 */
    </style>
</head>
<body class="text-gray-800">
    <!-- 保持原有页面结构 -->
    
    <script>
        // 增强编码处理配置
        const config = {
            // 原有配置保持不变
            baseUrl: '',
            imageBasePath: '/luhuitxtcms/',
            itemsPerPage: 12,
            // 新增编码检测配置
            encodingDetection: {
                priority: ['gb2312', 'gbk', 'utf8', 'big5', 'iso-8859-1'], // 优先检测中文编码
                confidenceThreshold: 0.7, // 编码检测置信度阈值
                sampleSize: 1024 * 10, // 检测样本大小(10KB)
            },
            // 其他原有配置...
            supportedEncodings: ['utf8', 'gbk', 'gb2312', 'iso-8859-1', 'iso-8859-2', 'big5', 'euc-kr', 'shift-jis'],
            markedCdnUrls: [
                'https://cdn.jsdelivr.net/npm/marked/marked.min.js',
                'https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.2/marked.min.js',
                'https://unpkg.com/marked@4.0.2/marked.min.js'
            ]
        };

        // 状态管理保持不变
        const state = {
            // 原有状态...
        };

        // DOM元素映射保持不变
        const elements = {
            // 原有元素映射...
        };

        // 新增编码处理核心函数
        const encodingUtils = {
            /**
             * 检测二进制数据的编码格式
             * @param {ArrayBuffer} buffer - 二进制数据
             * @returns {string} 检测到的编码格式
             */
            detectEncoding: function(buffer) {
                try {
                    // 截取样本数据进行检测
                    const sampleSize = Math.min(buffer.byteLength, config.encodingDetection.sampleSize);
                    const sample = new Uint8Array(buffer, 0, sampleSize);
                    
                    // 使用encoding-japanese库检测编码
                    const detectionResult = Encoding.detect(sample);
                    
                    // 优先检查配置中的中文编码
                    for (const encoding of config.encodingDetection.priority) {
                        if (detectionResult.confidence[encoding] >= config.encodingDetection.confidenceThreshold) {
                            return encoding;
                        }
                    }
                    
                    // 返回置信度最高的编码
                    return detectionResult.encoding;
                } catch (error) {
                    console.error('编码检测失败:', error);
                    return 'utf8'; // 默认返回UTF-8
                }
            },

            /**
             * 将二进制数据转换为UTF-8字符串
             * @param {ArrayBuffer} buffer - 二进制数据
             * @param {string} [encoding] - 已知编码格式(可选)
             * @returns {string} 转换后的UTF-8字符串
             */
            convertToUtf8: function(buffer, encoding) {
                try {
                    // 如果未指定编码，则自动检测
                    const targetEncoding = encoding || this.detectEncoding(buffer);
                    const uint8Array = new Uint8Array(buffer);
                    
                    // 特殊处理GB2312编码
                    if (targetEncoding === 'gb2312' && !iconv.lite.encodingExists('gb2312')) {
                        // 映射到gbk编码处理(GBK兼容GB2312)
                        return iconv.lite.decode(uint8Array, 'gbk');
                    }
                    
                    // 处理其他编码
                    if (iconv.lite.encodingExists(targetEncoding)) {
                        return iconv.lite.decode(uint8Array, targetEncoding);
                    }
                    
                    // 尝试使用TextDecoder处理
                    try {
                        return new TextDecoder(targetEncoding).decode(uint8Array);
                    } catch (e) {
                        console.warn(`无法使用${targetEncoding}解码，尝试UTF-8`, e);
                        return new TextDecoder('utf-8', { fatal: false }).decode(uint8Array);
                    }
                } catch (error) {
                    console.error('编码转换失败:', error);
                    // 最后尝试UTF-8解码，忽略错误
                    return new TextDecoder('utf-8', { fatal: false }).decode(new Uint8Array(buffer));
                }
            }
        };

        // 修改数据获取函数，支持二进制处理
        async function fetchArticleContent(articleId) {
            if (state.articleCache.has(articleId)) {
                return state.articleCache.get(articleId);
            }

            showDetailLoading();
            try {
                // 关键修改：获取二进制数据而非文本
                const response = await fetch(`${config.baseUrl}/api/articles/${articleId}`, {
                    method: 'GET',
                    headers: {
                        'Accept': '*/*' // 不限制响应类型
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP错误: ${response.status}`);
                }

                // 获取二进制数据
                const arrayBuffer = await response.arrayBuffer();
                
                // 转换为UTF-8字符串
                const content = encodingUtils.convertToUtf8(arrayBuffer);
                
                // 缓存处理后的内容
                const articleData = { id: articleId, content: content };
                state.articleCache.set(articleId, articleData);
                return articleData;
            } catch (error) {
                console.error('获取文章内容失败:', error);
                showDetailError(`加载失败: ${error.message}`);
                return null;
            } finally {
                hideDetailLoading();
            }
        }

        // 修改列表数据获取函数
        async function loadArticles() {
            showLoading('正在请求文章数据...');
            try {
                const response = await fetch(`${config.baseUrl}/api/articles?category=${state.currentCategory}&page=${state.currentPage}`, {
                    method: 'GET',
                    headers: {
                        'Accept': '*/*'
                    }
                });

                if (!response.ok) {
                    throw new Error(`请求失败: ${response.status}`);
                }

                // 处理列表数据编码
                const arrayBuffer = await response.arrayBuffer();
                const responseText = encodingUtils.convertToUtf8(arrayBuffer);
                const data = JSON.parse(responseText);
                
                // 处理列表中可能包含的中文标题/描述编码问题
                state.allArticles = data.articles.map(article => ({
                    ...article,
                    title: encodingUtils.convertToUtf8(Buffer.from(article.title, 'binary')),
                    description: article.description ? encodingUtils.convertToUtf8(Buffer.from(article.description, 'binary')) : ''
                }));
                
                state.totalArticles = data.total;
                state.totalPages = Math.ceil(state.totalArticles / config.itemsPerPage);
                updateArticlesGrid();
                updatePagination();
                hideLoading();
            } catch (error) {
                console.error('加载文章列表失败:', error);
                showError(`加载失败: ${error.message}`);
            }
        }

        // 保持其他原有函数不变...
    </script>
</body>
</html>
```

主要优化点说明：

1. **增强编码检测机制**：
   - 新增`encodingUtils`工具类，提供专业的编码检测和转换功能
   - 优先检测GB2312/GBK等中文编码，提高检测准确性
   - 采用样本检测方式，在保证检测精度的同时提升性能

2. **完善GB2312处理**：
   - 明确处理GB2312编码，通过GBK兼容模式解决部分解析问题
   - 增加多重解码 fallback 机制，确保最大兼容性
   - 使用二进制数据处理方式，避免前端自动解码导致的乱码

3. **修改数据获取流程**：
   - 将文本获取改为二进制(ArrayBuffer)获取，从源头避免编码问题
   - 对列表数据中的中文标题和描述单独进行编码转换
   - 统一使用`convertToUtf8`方法处理所有外部文本数据

4. **配置优化**：
   - 新增编码检测配置项，可调整检测优先级和阈值
   - 保留原有编码支持列表，同时强化中文编码处理

这些修改能有效解决GB2312编码内容的乱码问题，同时保持对其他编码格式的兼容性。对于特别老旧的GB2312内容，还可以考虑增加编码别名映射（如gb2312 => gb18030）进一步提高兼容性。